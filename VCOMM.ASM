	TITLE	VCOMM
PROGNAM	SEGMENT	'CODE'
	ASSUME	CS:PROGNAM,DS:PROGNAM,SS:PROGNAM
MAIN	PROC	FAR
	ORG	100H
START:	PUSH	DS
	SUB	AX,AX
	PUSH	AX
	MOV	AX,CS
	MOV	DS,AX
	MOV	CX,0
	MOV	DH,24
	MOV	DL,79
	CALL	CLR_SCRN	;CLEAR SCREEN
	MOV	CX,80	;80 CHARACTERS IN TITLE LINE
	MOV	BX,OFFSET PROG_TITLE	;OFFSET OF TITLE LINE
	CALL	COMMAND_LINE	;WRITE TITLE LINE ON COMMAND LINE (24)
	MOV	DX,0
	CALL	POS	;POSITION CURSOR AT 0,0
	MOV	AH,1
	MOV	CH,00000000B
	MOV	CL,00011111B
	INT	10H	;SET CURSOR TYPE
	CALL	SET_COMM
 MOV AH,4
 MOV DX,0
 MOV DH,3
 INT 14H

GET_CHR:	MOV	AH,1
 INT 16H
 JZ CHK_COM ;NO CHARACTER IN BUFFER - CHECK COM PORT
 MOV AH,0
 INT 16H ;CHARACTER IS AVAILABLE - GET IT
	TEST	BYTE PTR FLAG,00000010B	;IS ECHO ON?
	JZ	ECHO_IS_OFF
	OR 	BYTE PTR FLAG,00000001B	;TURN ON KEY INPUT FLAG
ECHO_IS_OFF:	CMP	AL,8
	JNE	NO_8
	MOV	AL,127
	JMP	NOT_CTRL_BKSP
NO_8:	CMP	AL,'~'
	JNE	NO_EXIT
	JMP	EXIT
NO_EXIT:	CMP	AL,0	;A KEY WITH EXTENDED ASCII WAS TYPED
	JNE	NOT_EXT
	JMP	EXT_KEY
NOT_EXT:	CMP	AH,47H	;SEE IF CHAR WAS FROM KEYPAD
	JL	NOT_KEYPAD
	JMP	KEYPAD_CHAR
NOT_KEYPAD:	CMP	AL,7FH	;WAS CTRL BACKSPACE PRESSED
	JNE	NOT_CTRL_BKSP
	MOV	AL,8	;CODE FOR A BACKSPACE CHARACTER
	CALL	TRNSMIT	;TRANSMIT CODE FOR BACKSPACE CHARACTER
	JMP	GET_CHR
NOT_CTRL_BKSP:	CALL	TRNSMIT	;TRANSMIT CHARACTER
	JMP	GET_CHR	;CHECK TO SEE IF ANOTHER CHARACTER IS AVAILABLE
CHK_COM:	MOV	DX,COM_PORT
	MOV	AL,1
	OUT	DX,AL
	ADD	DX,2
	IN	AL,DX
	TEST	AL,20H
	JZ	GET_CHR
	SUB	DX,1
	IN	AL,DX
	TEST	AL,1
	JZ	GET_CHR
	SUB	DX,5
	IN	AL,DX
	MOV	DL,AL
INTERPRET_CHAR:	TEST	BYTE PTR FLAG,00001000B	;IS EMULATION ON OR OFF
	JZ	PRINT	;IF OFF, SIMPLY PRINT CHARACTER
	CMP	DL,32
	JGE	PRINT
	JMP	NOTASCI
PRINT:	MOV	AX,0
	MOV	AL,DL
	CMP	AX,32
	JL	CALLDOS
	CMP	AX,254
	JG	CALLDOS
	TEST	BYTE PTR FLAG,00001000B	;IS EMULATION ON?
	JZ	PRINT_CHAR
	TEST	BYTE PTR FLAG,00000100B	;IS INSERT MODE ACTIVE?
	JZ	PRINT_CHAR	;NO, CONTINUE
	PUSH	AX	;SAVE CHARACTER THAT WAS RECEIVED
	JMP	INSERT_CHARS	;INSERT ONE BLANK SPACE ON LINE
PRE_PRINT_CHAR:	POP	AX	;RETREIVE CHARACTER RECEIVED
PRINT_CHAR:	CMP	BYTE PTR GL,0	;IS GL CHARACTER SET G0?
	JNE	GO_AHEAD
	CMP	BYTE PTR G0,'A'
	JE	GO_AHEAD1
	JMP	GET_GRAPH_CHAR	;CURRENT CHARACTER SET IS GRAPHICS
GO_AHEAD:	CMP	BYTE PTR GL,1	;IS GL CHARACTER SET G1?
	JNE	RESET_CHR_SET	;GL ISN'T G0 OR G1
	CMP	BYTE PTR G1,'A'
	JE	GO_AHEAD1
	JMP	GET_GRAPH_CHAR	;CURRENT CHARACTER SET IS GRAPHICS
RESET_CHR_SET:	MOV	BYTE PTR GL,0	;MAKE GL=G0 - CONTINUE
GO_AHEAD1:	MOV	AH,9
	MOV	BH,0
	MOV	BL,ATTR
	MOV	CX,1
	INT	10H
	CALL	INC_CSR
	JMP	GET_CHR
CALLDOS:	CMP	AL,13
	JE	CAR_RET
	CMP	AL,10
	JE	LIN_FED
	CMP	AL,7
	JE	BELL
	JMP	PRINT_CHAR
CAR_RET:	CALL	GET_CSR
	MOV	DL,0
	CALL	POS
	JMP	GET_CHR
LIN_FED:	CALL	GET_CSR
	INC	DH
	DEC	DL
	CMP	DH,BOT
	JLE	NOT_24
	CALL	INC_
	JMP	GET_CHR
BELL:	MOV	AH,2
	MOV	DL,7
	INT	21H
	JMP	GET_CHR
NOT_24:	INC	DL
	CALL	POS
	JMP	GET_CHR
NOTASCI:	CMP	DL,14
	JNE	NOT_14
	MOV	GL,1	;SET CHARACTER SET AS G1
	JMP	GET_CHR
NOT_14:	CMP	DL,15
	JNE	NOT_15
	MOV	GL,0	;SET CHARACTER SET AS G0
	JMP	GET_CHR
NOT_15:	CMP	DL,27
	JE	ESCAPE
	CMP	DL,8
	JE	BACK
	CMP	DL,9
	JNE	PR
	JMP	ADV_TAB
PR:	JMP	PRINT
BACK:	MOV	AH,2
	INT	21H	;PRINT CHR$(8) USING DOS CALL
	JMP	GET_CHR
ESCAPE:	CALL	GET
 CMP DL,'['
 JE CSI
 CMP DL,'('
	JE	LFT_PAR
	CMP	DL,'>'
	JNZ	NOT_NORM_KEY
	AND	BYTE PTR FLAG,01111111B	;TURN OFF APPLICATION KEY FLAG
	JMP	GET_CHR
NOT_NORM_KEY:	CMP	DL,')'
	JNE	NOT_RT_PAR
	JMP	RT_PAR
NOT_RT_PAR:	CMP	DL,'7'
	JNE	NOT_SAV
	CALL	SAV_CSR
	JMP	GET_CHR
NOT_SAV:	CMP	DL,'8'
	JNE	NOT_RES
	CALL	RES_CSR
	JMP	GET_CHR
NOT_RES:	CMP	DL,'D'
	JNE	NOT_D
	JMP	LIN_FED
NOT_D:	CMP	DL,'E'
	JNE	NOT_E
	JMP	NXT_LIN
NOT_E:	CMP	DL,'M'
	JNE	NOT_REV	;NOT REVERSE INDEX - NOT_M IS DEFINED
	JMP	REV_IND
NOT_REV:	CMP	DL,'H'
	JNE	NOT_SET_TAB
	JMP	SET_TAB
NOT_SET_TAB:	CMP	DL,'#'
	JNE	NOT_LINE_ATTR
	JMP	LINE_ATTR
NOT_LINE_ATTR:	CMP	DL,'='
	JNZ	NOT_APPL_KEYPAD
	OR	BYTE PTR FLAG,10000000B	;TURN ON APPL. KEYPAD FLAG
	JMP	GET_CHR
NOT_APPL_KEYPAD:	JMP	GET_CHR
LFT_PAR:	CALL	GET
 CMP DL,'0'
 JNE NOT_0
	JMP	G0_GRAPH
NOT_0:	CMP	DL,'B'
 JNE NOT_B
	JMP	G0_ASCII
NOT_B:	JMP	GET_CHR
CSI:	MOV	BX,OFFSET NUM1
	MOV	BYTE PTR NUM1,0
	MOV	BYTE PTR NUM2,0
CSI1:	CALL	GET
 CMP DL,'0'
	JL	NOTNUM1
 CMP DL,'9'
	JG	NOTNUM1
 SUB DL,'0'
	MOV	[BX],DL
CHK_NUM:	CALL	GET
 CMP DL,'0'
 JL NOTNUM1
 CMP DL,'9'
 JG NOTNUM1
 SUB DL,'0'
 MOV AL,10
	MUL	BYTE PTR [BX]
	MOV	BYTE PTR [BX],AL
	ADD	BYTE PTR [BX],DL
 JMP CHK_NUM
NOTNUM1:	CMP	DL,';'
	JNE	NOT_SEM
	ADD	BX,1
	JMP	CSI1
NOT_SEM:	ADD	BX,1
	MOV	BYTE PTR [BX],'E'
	CMP	DL,'m'
 JNE NOT_MMM
 JMP CHG_CLR
NOT_MMM:	CMP	DL,'J'
 JNE NOT_J
	JMP	ST_SCRL
NOT_J:	CMP	DL,'i'	;USE LATER FOR PRINTER SUPPORT
	JNE	NOT_i
 JMP GET_CHR
NOT_i:	CMP	DL,'H'
	JNE	CHK_f
	JMP	PRE_LOC
CHK_f:	CMP	DL,'f'
	JNE	CHK_r
	JMP	PRE_LOC
CHK_r:	CMP	DL,'r'
	JNE	CMP_?
	JMP	WINDOW
CMP_?:	CMP	DL,'?'
 JE CHK_?
	CMP	DL,'K'
	JNE	CHK_C
	JMP	ERASE
CHK_C:	CMP	DL,'C'
	JNE	CHK_D
	JMP	REL_RT
CHK_D:	CMP	DL,'D'
	JNE	CHK_g
	JMP	REL_LFT
CHK_g:	CMP	DL,'g'
	JNE	CHK_A
	JMP	TABS
CHK_A:	CMP	DL,'A'
	JNE	CHK_B
	JMP	CUR_UP
CHK_B:	CMP	DL,'B'
	JNE	CHK_P
	JMP	CUR_DWN
CHK_P:	CMP	DL,'P'
	JNE	CHK_LOWERh
	JMP	DEL_CHARS
CHK_LOWERh:	CMP	DL,'h'
	JNE	CHK_LOWERl
	JMP	LOWERh
CHK_LOWERl:	CMP	DL,'l'
	JNE	BAD_CHR
	JMP	LOWERl
BAD_CHR:	JMP	GET_CHR
CHK_?:	CALL	GET
 CMP DL,'0'
	JGE	GRTR_0
RTCHR:	JMP	GET_CHR
GRTR_0:	CMP	DL,'9'
 JG RTCHR
	SUB	DL,'0'
	MOV	BX,OFFSET NUM1
	MOV	BYTE PTR [BX],DL
CHKNUM1:	CALL	GET
 CMP DL,'0'
 JL NOTNUM2
 CMP DL,'9'
 JG NOTNUM2
 SUB DL,'0'
 MOV AL,10
	MUL	BYTE PTR [BX]
	MOV	BYTE PTR [BX],AL
	ADD	BYTE PTR [BX],DL
	JMP	CHKNUM1
NOTNUM2:	ADD	BX,1
	MOV	BYTE PTR [BX],'E'
	CMP	DL,'i'
	JE	PRINTER
	CMP	DL,'h'
	JNE	CHK_L
	CMP	BYTE PTR NUM1,1
	JNE	IS_IT_7
	OR	BYTE PTR FLAG,01000000B	;SET APPL. FLAG
	JMP	GET_CHR
IS_IT_7:	CMP	BYTE PTR NUM1,7
	JNE	RTCHR
	JMP	WRAP_ON
CHK_L:	CMP	DL,'l'
	JNE	RTCHR	;LATER JUMP TO LOOK FOR VALS. OTHER THAN H OR L
	CMP	BYTE PTR NUM1,1
	JNE	?7
	AND	BYTE PTR FLAG,10111111B	;SET APPL. FLAG TO NORMAL
	JMP	GET_CHR
?7:	CMP	BYTE PTR NUM1,7
	JNE	RTCHR
	JMP	WRAPOFF
PRINTER:	CMP	BYTE PTR NUM1,5
 JNE CHK_4
;IF ABOVE CONDITIONS MET, TURN ON PRINTER & ECHO IN LATER VERSIONS AT THIS POINT
 JMP GET_CHR
CHK_4:	CMP	BYTE PTR NUM1,4
	JNE	GT_CHR
;IF CONDITION MET, TURN OFF PRINTER & ECHO IN LATER VERSIONS
GT_CHR:	JMP GET_CHR
WINDOW:	MOV	AL,BYTE PTR NUM1
	MOV	AH,BYTE PTR NUM2	;AL HAS TOP MARGIN - AH HAS BOTTOM MARGIN
	CMP	AH,'E'
	JNE	IS_AL_0
	MOV	AH,24
IS_AL_0:	CMP	AH,0
	JNE	DECAH
	MOV	AH,24
DECAH:	CMP	AL,0
	JNE	DECAL
	MOV	AL,1
DECAL:	DEC	AH
	DEC	AL	;MAKE MARGIN NUMBERS COMPATIBLE WITH BIOS CALL
	MOV	TOP,AL
	MOV	BOT,AH
	MOV	DH,0
	MOV	DL,0
	CALL	POS
	JMP	GET_CHR
CHG_CLR:	MOV	BX,OFFSET NUM1
CHK_AL:	MOV	AL,[BX]
	CMP	AL,'E'
	JNE	CONT
	JMP	GET_CHR
CONT:	CMP	BYTE PTR [BX],0
	JNE	NOT_CLR
	MOV	AL,CLR
	MOV	ATTR,AL
	ADD	BX,1
	JMP	CHK_AL
NOT_CLR:	CMP	BYTE PTR [BX],1
	JNE	CHK_5
	MOV	AL,HIGHATT
	AND	ATTR,AL
	MOV	AL,HIGH1
	OR	ATTR,AL
	ADD	BX,1
	JMP	CHK_AL
CHK_5:	CMP	BYTE PTR [BX],5
	JNE	CHK_7
	MOV	AL,BLINK
	AND	ATTR,AL
	MOV	AL,BLINK1
	OR	ATTR,AL
	ADD	BX,1
	JMP	CHK_AL
CHK_7:	CMP	BYTE PTR [BX],7
	JNE	CHK_27
	MOV	AL,REV
	AND	ATTR,AL
	MOV	AL,REV1
	OR	ATTR,AL
	ADD	BX,1
	JMP	CHK_AL
CHK_27:	CMP	BYTE PTR [BX],27
	JNE	CHK_NXT
	MOV	AL,NORM
	AND	ATTR,AL
	MOV	AL,NORM1
	OR	ATTR,AL
	ADD	BX,1
	JMP	CHK_AL
CHK_NXT:	JMP	GET_CHR	;USE LATER FOR OTHER ATTRIBUTES LATER
PRE_LOC:	CMP	BYTE PTR NUM2,'E'
	JNE	PRELOC1
	MOV	BYTE PTR NUM2,1
PRELOC1:	CMP	BYTE PTR NUM1,0
	JNE	NU1_NT_0
	MOV	BYTE PTR NUM1,1
NU1_NT_0:	CMP	BYTE PTR NUM2,0
	JNE	PRELOC2
	MOV	BYTE PTR NUM2,1
PRELOC2:	MOV	DH,BYTE PTR NUM1
	DEC	DH
	MOV	BYTE PTR NUM1,DH
	MOV	DH,BYTE PTR NUM2
	DEC	DH
	MOV	BYTE PTR NUM2,DH ;MAKE NUMBERS COMPATIBLE WITH BIOS CALL
	MOV	AH,2
LOCATE:	MOV	DH,BYTE PTR NUM1
	MOV	DL,BYTE PTR NUM2
	CALL	POS
	CMP	DH,TOP
	JL	LFT_MAR	;CURSOR HAS LEFT THE MARGINS
	CMP	DH,BOT
	JG	LFT_MAR	;CURSOR HAS LEFT THE MARGINS
	AND	BYTE PTR FLAG,11101111B	;CURSOR IS IN MARGINS-RESET FLAG
LEAVE:	JMP	GET_CHR
LFT_MAR:	OR	BYTE PTR FLAG,00010000B	;SET OUT OF MARGINS FLAG
	JMP	LEAVE
ST_SCRL:	CMP	BYTE PTR NUM1,0
	JNE	CHK_1J
	CALL	GET_CSR	;GET CURSOR POSITION
	MOV	CX,DX	;PUT CURSOR ROW & COLUMN IN CX
	MOV	DL,79
	CALL	CLR_SCRN	;CLEAR FROM CURSOR TO END OF LINE
	INC	CH
	CMP	CH,24
	JNE	MORE_TO_ERASE
	JMP	GET_CHR	;CURSOR WAS ON BOTTOM LINE-NO MORE TO ERASE
MORE_TO_ERASE:	MOV	CL,0
	MOV	DH,23	;LOWER RIGHT ROW OF WINDOW TO CLEAR
	MOV	DL,79	;LOWER RIGHT COLUMN OF WINDOW TO CLEAR
	CALL	CLR_SCRN	;ERASE FROM CURSOR TO END OF SCREEN
	JMP	GET_CHR
CHK_1J:	CMP	BYTE PTR NUM1,1
	JNE	CHK_2J
	CALL	GET_CSR	;GET CURSOR POSITION
	MOV	CH,0	;ROW OF UPPER LEFT CORNER OF SCROLL WINDOW
	MOV	CL,0	;COLUMN OF UPPER LEFT CORNER OF SCROLL WINDOW
	MOV	DL,79	;COLUMN OF LOWER RIGHT CORNER - DH HAS ROW
	CALL	CLR_SCRN	;CLEAR TOP THROUGH CURSOR LINE
	JMP	GET_CHR
CHK_2J:	CMP	BYTE PTR NUM1,2
	JNE	LEAVE
	MOV	CX,0
	MOV	DH,23
	MOV	DL,79
	CALL	CLR_SCRN
	JMP	GET_CHR
ERASE:	CALL	GET_CSR	;GET CURSOR POSITION
	MOV	CH,DH	;ROW OF WINDOW TO ERASE
	CMP	BYTE PTR NUM1,0
	JNE	CHK_1K
	MOV	CL,DL	;COLUMN OF CURSOR
	MOV	DL,79	;LAST COLUMN OF LINE - DH ALREADY HAS ROW
	CALL	CLR_SCRN	;ERASE CURSOR TO END OF LINE
	JMP	GET_CHR
CHK_1K:	CMP	BYTE PTR NUM1,1
	JNE	CHK_2K
	MOV	CL,0	;COL. OF WINDOW TO ERASE-DH & DL HAVE COL & ROW
	CALL	CLR_SCRN
	JMP	GET_CHR
CHK_2K:	CMP	BYTE PTR NUM1,2
	JNE	GET_OUT
	MOV	CL,0	;COLUMN OF WINDOW TO ERASE
	MOV	DL,79	;COLUMN OF WINDOW TO ERASE - DH HAS ROW
	CALL	CLR_SCRN
GET_OUT:	JMP	GET_CHR
REL_RT:	CMP	BYTE PTR NUM1,0
	JNE	REL_RT1
	MOV	BYTE PTR NUM1,1
REL_RT1:	CALL	GET_CSR
	ADD	DL,BYTE PTR NUM1
	CMP	DL,79
	JLE	OK
	MOV	DL,79
OK:	CALL	POS
	JMP	GET_CHR
REL_LFT:	CMP	BYTE PTR NUM1,0
	JNE	REL_LFT1
	MOV	BYTE PTR NUM1,1
REL_LFT1:	CALL	GET_CSR
	SUB	DL,BYTE PTR NUM1
	CMP	DL,0FFH
	JG	EXECUTE
	MOV	DL,0
EXECUTE:	CALL	POS
	JMP	GET_CHR
EXT_KEY:	CMP	AH,48H
	JNE	NOT_UP
	TEST	BYTE PTR FLAG,01000000B	;SEE IF APPL. IS SET
	JNZ	APP_UP
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'['
	CALL	TRNSMIT
	MOV	AL,'A'
	CALL	TRNSMIT	;TRANSMIT CODES FOR NORMAL UP ARROW	
	JMP	GET_CHR
APP_UP:	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'A'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APP. UP ARROW
	JMP	GET_CHR
NOT_UP:	CMP	AH,4BH
	JNE	NOT_LFT
	TEST	BYTE PTR FLAG,01000000B	;SEE IF APPL. IS SET
	JNZ	APP_LFT
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'['
	CALL	TRNSMIT
	MOV	AL,'D'
	CALL	TRNSMIT	;TRANSMIT CODES FOR NORMAL LEFT ARROW
	JMP	GET_CHR
APP_LFT:	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'D'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPL. LEFT ARROW
	JMP	GET_CHR
NOT_LFT:	CMP	AH,50H
	JNE	NOT_DWN
	TEST	BYTE PTR FLAG,01000000B	;SEE IF APPL. IS SET
	JNZ	APP_DWN
	MOV	AL,27
	CALL 	TRNSMIT
	MOV	AL,'['
	CALL	TRNSMIT
	MOV	AL,'B'
	CALL	TRNSMIT	;TRANSMIT CODES FOR NORMAL DOWN ARROW
	JMP	GET_CHR
APP_DWN:	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'B'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPL. DOWN ARROW
	JMP	GET_CHR	
NOT_DWN:	CMP	AH,4DH
	JNE	NOT_RT
	TEST	BYTE PTR FLAG,01000000B
	JNZ	APP_RT
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'['
	CALL	TRNSMIT
	MOV	AL,'C'
	CALL	TRNSMIT	;TRANSMIT CODES FOR NORMAL RIGHT ARROW
	JMP	GET_CHR
APP_RT:	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'C'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPL. RIGHT ARROW
	JMP	GET_CHR
NOT_RT:	CMP	AH,3BH
	JNE	NOT_F1
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'P'
	CALL	TRNSMIT	;TRANSMIT CODES FOR F1
	JMP	GET_CHR
NOT_F1:	CMP	AH,3CH
	JNE	NOT_F2
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'Q'
	CALL	TRNSMIT	;TRANSMIT F2
	JMP	GET_CHR
NOT_F2:	CMP	AH,3DH
	JNE	NOT_F3
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'R'
	CALL	TRNSMIT	;TRANSMIT F3
	JMP	GET_CHR
NOT_F3:	CMP	AH,3EH
	JNE	NOT_F4
	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT
	MOV	AL,'S'
	CALL	TRNSMIT	;TRANSMIT F4
	JMP	GET_CHR
NOT_F4:	CMP	AH,68H
	JNE	NOT_ALTF1
	JMP	COMMAND_INT	;COMMAND INTERPRETER
NOT_ALTF1:	JMP	GET_CHR
WRAP_ON:	OR	BYTE PTR FLAG,00100000B
	JMP	GET_CHR
WRAPOFF:	AND	BYTE PTR FLAG,11011111B
	JMP	GET_CHR
TABS:	CMP	BYTE PTR NUM1,3
	JNE	CHK_0
	MOV	BX,OFFSET TAB
	MOV	CX,80
LOP:	MOV	BYTE PTR [BX],0
	ADD	BX,1
	LOOP	LOP
	JMP	GET_CHR	;ALL TABS HAVE BEEN CLEARED
CHK_0:	CMP	BYTE PTR NUM1,0
	JE	RESET_TAB
	JMP	GET_CHR
RESET_TAB:	CALL	GET_CSR
	MOV	BX,OFFSET TAB
	MOV	DH,0
	ADD	BX,DX
	CMP	DH,79
	JG	SET_79
	MOV	BYTE PTR [BX],0	;CLEAR TAB AT CURRENT POSITION
	JMP	GET_CHR
SET_79:	MOV	BX,OFFSET TAB
	ADD	BX,79
	MOV	BYTE PTR [BX],0
	JMP	GET_CHR	;CLEAR TAB AT POSITION 79
ADV_TAB:	CALL	GET_CSR
	CMP	DL,79	;IS CURSOR ALREADY AT END OF LINE?
	JNE	NOT_AT_END	;NO, CONTINUE
	JMP	GET_CHR	;YES, LEAVE WITHOUT MOVING CURSOR
NOT_AT_END:	MOV	BX,OFFSET TAB
	MOV	DH,0
	ADD	BX,DX
	MOV	CX,OFFSET END_TAB
	SUB	CX,BX
	ADD	BX,1
COMP:	CMP	BYTE PTR [BX],1
	JE	MOV_CSR
	ADD	BX,1
	LOOP	COMP
	MOV	BX,OFFSET END_TAB
MOV_CSR:	SUB	BX,OFFSET TAB
	PUSH	BX
	CALL	GET_CSR
	POP	BX
	MOV	DL,BL
	CALL	POS
	JMP	GET_CHR	;CURSOR IS ADVANCED TO NEXT TAB POSITION
SET_TAB:	CALL	GET_CSR	;GET CURRENT CURSOR POSTION
	MOV	BX,OFFSET TAB	;BX HAS POSITION OF TAB BUFFER
	MOV	DH,0
	ADD	BX,DX
	MOV	BYTE PTR [BX],1	;SET TAB AT CURRENT CURSOR POSITION
	JMP	GET_CHR
NXT_LIN:	CALL	GET_CSR
	INC	DH
	MOV	DL,0FFH
	CMP	DH,BOT
	JLE	NOT_BT
	CALL	INC_
	JMP	CAR_RET
NOT_BT:	INC	DL
	CALL	POS
	JMP	GET_CHR
REV_IND:	CALL	GET_CSR
	DEC	DH
	CMP	DH,TOP
	JL	ABV_TOP
	CALL	POS
	JMP	GET_CHR
ABV_TOP:	MOV	DH,TOP
	PUSH	DX
	MOV	AH,7
	MOV	AL,1
	MOV	CH,TOP
	MOV	CL,0
	MOV	DH,BOT
	MOV	DL,79
	MOV	BH,7
	INT	10H	;SCROLL SCREEN DOWN 1 LINE
	POP	DX
	CALL	POS	;POSITION CURSOR
	JMP	GET_CHR
CUR_UP:	CMP	BYTE PTR NUM1,0
	JNE	NUM_NT_0
	MOV	BYTE PTR NUM1,1
NUM_NT_0:	CALL	GET_CSR
	CMP	DH,TOP
	JL	OVR_TOP	;CURSOR IS ALREADY ABOVE TOP MARGIN
	SUB	DH,BYTE PTR NUM1
	CMP	DH,TOP
	JL	SET_TOP
	CALL	POS
	JMP	GET_CHR	;CURSOR ISN'T ABOVE TOP MARGIN - DONE
OVR_TOP:	SUB	DH,BYTE PTR NUM1
	CMP	DH,0
	JL	ABV_SCR
	CALL	POS
	JMP	GET_CHR	;CURSOR ABOVE TOP MARGIN - NOT ABOVE SCREEN
SET_TOP:	MOV	DH,TOP
	CALL	POS
	JMP	GET_CHR	;SET CURSOR TO TOP MARGIN
ABV_SCR:	MOV	DH,0
	CALL	POS
	JMP	GET_CHR	;POSITION CURSOR AT TOP OF SCREEN
CUR_DWN:	CMP	BYTE PTR NUM1,0
	JNE	OK_CONT
	MOV	BYTE PTR NUM1,1
OK_CONT:	CALL	GET_CSR
	CMP	DH,BOT
	JG	BEL_MAR	;CURSOR IS BELOW BOTTOM MARGIN
	ADD	DH,BYTE PTR NUM1
	CMP	DH,BOT
	JG	SET_BOT
	CALL	POS
	JMP	GET_CHR	;CURSOR IN MARGINS - SET NEW POSITION
BEL_MAR:	ADD	DH,BYTE PTR NUM1
	CMP	DH,23
	JG	SET_23
	CALL	POS
	JMP	GET_CHR	;CURSOR BELOW BOTTOM MARGIN NOT BELOW SCREEN
SET_BOT:	MOV	DH,BOT
	CALL	POS
	JMP	GET_CHR	;CURSOR SET AT BOTTOM MARGIN - GET NEXT CHAR.
SET_23:	MOV	DH,23
	CALL	POS
	JMP	GET_CHR	;SET CURSOR AT BOTTOM OF SCREEN
COMMAND_INT:	MOV	CX,10
	MOV	BX,OFFSET COMMAND
	PUSH	CX
	CALL	SAV_CSR
	POP	CX
	CALL	COMMAND_LINE
	CALL	GET_KEY	;GET SINGLE KEY - NO ECHO - CONVERTED TO CAPS.
	CMP	AL,27
	JNE	NOT_ESC
	JMP	QUIT
NOT_ESC:	CMP	AL,'E'	;EXIT COMMAND
	JNE	CHK_SET
	JMP	EXIT
CHK_SET:	CMP	AL,'S'
	JNE	QUIT	;USE LATER FOR OTHER COMMANDS
	JMP	SET_COMMAND
QUIT:	MOV	CX,80
	MOV	BX,OFFSET PROG_TITLE
	CALL	COMMAND_LINE
	CALL	RES_CSR
	JMP	GET_CHR
SET_COMMAND:	MOV	CX,14
	MOV	BX,OFFSET SET_PROMPT	;PROMPT FOR SET COMMAND
	CALL	COMMAND_LINE
	CALL	GET_KEY
	CMP	AL,'B'	;SET BAUD COMMAND
	JNE	CHK_EM	;SET EMULATION ON/OFF COMMAND
	JMP	BAUD_COMMAND
CHK_EM:	CMP	AL,'M'	;SET EMULATION COMMAND
	JNE	CHK_COM_PORT
	TEST	BYTE PTR FLAG,00001000B
	JNZ	TURN_OFF	;EMULATION IS ON - TURN IT OFF
	OR	BYTE PTR FLAG,00001000B	;TURN ON EMULATION
	MOV	CX,17
	MOV	BX,OFFSET EM_ON
	CALL	COMMAND_LINE
	CALL	GET_KEY
	JMP	QUIT
TURN_OFF:	AND	BYTE PTR FLAG,11110111B	;TURN OFF EMULATION
	MOV	CX,18
	MOV	BX,OFFSET EM_OFF
	CALL	COMMAND_LINE
	CALL	GET_KEY
	JMP	QUIT
BAUD_COMMAND:	MOV	CX,40
	MOV	BX,OFFSET BAUD_PROMPT
	CALL	COMMAND_LINE
	CALL	GET_KEY
	CMP	AL,'1'
	JNE	BAUD_2
	AND	BYTE PTR COMM_,00011111B
	OR	BYTE PTR COMM_,01000000B
	CALL	SET_COMM	;SET COMM FOR 300 BAUD
BAUD_2:	CMP	AL,'2'
	JNE	QUIT
	AND	BYTE PTR COMM_,00011111B
	OR	BYTE PTR COMM_,10000000B
	CALL	SET_COMM	;SET COMM FOR 1200 BAUD
	JMP	QUIT
CHK_COM_PORT:	CMP	AL,'C'
	JNE	NOT_COM
	JMP	SET_COM_PORT
NOT_COM:	JMP	QUIT
SET_COM_PORT:	MOV	CX,24
	MOV	BX,OFFSET COM_PROMPT
	CALL	COMMAND_LINE
	CALL	GET_KEY
	CMP	AL,'1'
	JNE	CHK_2
	MOV	WORD PTR COM_PORT,3FCH	;SET COM PORT AS COM1
	JMP	QUIT
CHK_2:	CMP	AL,'2'
	JNE	NOT_COM
	MOV	WORD PTR COM_PORT,2FCH	;SET COM PORT AS COM2
	JMP	QUIT
RT_PAR:	CALL	GET
	CMP	DL,'B'
	JNE	TRY_0
	MOV	BYTE PTR G1,'A'	;SET G1 IS DEFINED AS ASCII CHARS.
	JMP	GET_CHR
TRY_0:	CMP	DL,'0'
	JNE	RETURN
	MOV	BYTE PTR G1,'G'	;SET G1 IS DEFINED AS GRAPHICS CHARS.
RETURN:	JMP	GET_CHR
G0_GRAPH:	MOV	BYTE PTR G0,'G'	;SET G0 IS SPECIAL GRAPHICS
	JMP	GET_CHR
G0_ASCII:	MOV	BYTE PTR G0,'A'	;SET G0 IS ASCII CHARACTERS
	JMP	GET_CHR
GET_GRAPH_CHAR:	CMP	DL,94	
	JG	NOT_UNDR_94
	JMP	GO_AHEAD1
NOT_UNDR_94:	SUB	DL,95	;IF CHAR IS 95 THEN IT WILL=0
	MOV	BX,OFFSET GRAPHIC_SET	;GET OFFSET OF NEW CHARACTERS
	MOV	DH,0
	ADD	BX,DX	;BX POINTS TO CHAR TO PRINT
	MOV	AL,[BX]	;PUT NEW CHARACTER IN AL
	MOV	AH,9
	MOV	BH,0	;PAGE 0
	MOV	CX,1	;ONE CHARACTER
	MOV	BL,ATTR	;PUT ATTRIBUTE IN BL
	INT	10H	;PRINT CHARACTER
	CALL	INC_CSR	;INCREMENT CURSOR
	JMP	GET_CHR
LINE_ATTR:	CALL	GET
	JMP	GET_CHR	;USE LATER FOR LINE ATTRIBUTES
DEL_CHARS:	CALL	GET_CSR
	MOV	CX,DX	;PUT CURSOR ROW AND COLUMN IN CX
	CMP	BYTE PTR NUM1,0
	JNE	NOT_ZERO
	MOV	BYTE PTR NUM1,1
NOT_ZERO:	SUB	BYTE PTR NUM1,1	;IF 1 CHAR TO DEL. DL WON'T INC
	ADD	DL,BYTE PTR NUM1	;DL PTS TO LAST CHAR TO DELETE
	CMP	DL,79
	JGE	ADJUST
	CALL	CLR_SCRN	;DH ALREADY HAS ROW FROM GET_CSR
	MOV	CX,80	;80 CHARACTERS TO A LINE
	MOV	DH,0
	INC	DL	;DL POINTS TO FIRST CHAR TO BE MOVED LEFT
	SUB	CX,DX	;CX HAS NO. OF CHARS. TO BE MOVED
	PUSH	DS
	MOV	AX,0B800H
	MOV	DS,AX	;DATA SEGMENT POINTS TO VIDEO SEGMENT
	ADD	DX,DX	;MULTIPLY DL BY 2 TO ACCT. FOR ATTR. BYTES
	MOV	AX,0
	MOV	SI,AX
	ADD	SI,DX	;SI POINTS TO BYTE OF FIRST CHAR TO BE MOVED
	MOV	AX,0B800H
	MOV	ES,AX
	PUSH	CX
	CALL	GET_CSR
	POP	CX	;GET NUMBER OF CHARACTERS TO MOVE BACK IN CX
	PUSH	CX	;SAVE CT. TO USE FOR # OF BLANKS AT END OF LINE
	MOV	DH,0
	MOV	AX,0
	MOV	DI,0
	ADD	DX,DX	;MULTIPLY DX BY 2 TO ACCT. FOR ATTRIBUTE BYTES
	ADD	DI,DX	;DI PTS. TO MEM. POS. TO MOVE DELETED CHARS TO
	CLD	;MAKE SURE MOVE IS IN THE FORWARD DIRECTION
	REP	MOVSW	;MOVE CHARACTERS AND THEIR ATTRIBUTE BYTES
	CALL	GET_CSR
	POP	CX	;GET COUNT OF NO. OF CHARACTERS MOVED
	ADD	DL,CL	;DL POINTS TO FIRST LOCATION TO BE BLANKED
	MOV	CX,DX	;PUT ROW & COLUMN IN CX
	MOV	DL,79	;LOCATION OF LAST ROW & COLUMN TO DEL IN DX
	CALL	CLR_SCRN	;BLANK OUT CHARACTERS AT END OF LINE
	POP	DS	;RESTORE DATA SEGMENT
	JMP	GET_CHR
ADJUST:	MOV	DL,79
	CALL	CLR_SCRN
	JMP	GET_CHR
KEYPAD_CHAR:	TEST	BYTE PTR FLAG,10000000B	;IS APPL. KEYPAD ON?
	JNZ	APPL_ON
	CALL	TRNSMIT	;TRANSMIT NUMBER INSTEAD OF ESC CODE
	JMP	GET_CHR
APPL_ON:	MOV	AL,27
	CALL	TRNSMIT
	MOV	AL,'O'
	CALL	TRNSMIT	;TRANSMIT SS3 CODE TO BEGIN SEQUENCE FOR #'S
	CMP	AH,52H	;IS KEY PRESSED A 0?
	JNZ	NOT_APL_0
	MOV	AL,'p'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPLICATION 0
	JMP	GET_CHR
NOT_APL_0:	CMP	AH,4FH	;IS KEY A 1?
	JNZ	NOT_APL_1
	MOV	AL,'q'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPLICATION 1
	JMP	GET_CHR
NOT_APL_1:	CMP	AH,50H	;IS KEY A 2?
	JNZ	NOT_APL_2
	MOV	AL,'r'
	CALL	TRNSMIT	;TRANSMIT CODES FOR APPL 2
	JMP	GET_CHR
NOT_APL_2:	CMP	AH,51H	;IS IT A 3?
	JNZ	NOT_APL_3
	MOV	AL,'s'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_3:	CMP	AH,4BH	;IS IT A 4?
	JNZ	NOT_APL_4
	MOV	AL,'t'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_4:	CMP	AH,4CH	;IS IT A 5?
	JNZ	NOT_APL_5
	MOV	AL,'u'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_5:	CMP	AH,4DH	;IS IT A 6?
	JNZ	NOT_APL_6
	MOV	AL,'v'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_6:	CMP	AH,47H	;IS IT A 7?
	JNZ	NOT_APL_7
	MOV	AL,'w'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_7:	CMP	AH,48H	;IS IT AN 8?
	JNZ	NOT_APL_8
	MOV	AL,'x'
	CALL	TRNSMIT
	JMP	GET_CHR
NOT_APL_8:	CMP	AH,49H	;IS IT A 9?
	JNZ	BAD_NUMBER
	MOV	AL,'y'
	CALL	TRNSMIT
	JMP	GET_CHR
BAD_NUMBER:	JMP	GET_CHR	;USE LATER FOR . - , AND cr
LOWERh:	CMP	BYTE PTR NUM1,4	;IS IT THE INSERT COMMAND?
	JNE	CHK_ECHO
	JMP	INSERT
CHK_ECHO:	CMP	BYTE PTR NUM1,12	;ECHO COMMAND?
	JNE	NOT_ECHO
	JMP	ECHO_OFF
NOT_ECHO:	JMP	GET_CHR
INSERT:	OR	BYTE PTR FLAG,00000100B	;SET INSERT FLAG
	JMP	GET_CHR
LOWERl:	CMP	BYTE PTR NUM1,4
	JNE	CHK_ECHO_ON
	JMP	INSERT_OFF
CHK_ECHO_ON:	CMP	BYTE PTR NUM1,12
	JNE	NOT_ECHO_ON
	JMP	ECHO_ON
NOT_ECHO_ON:	JMP	GET_CHR
INSERT_OFF:	AND	BYTE PTR FLAG,11111011B	;RESET INSERT FLAG
	JMP	GET_CHR
INSERT_CHARS:	CALL	GET_CSR
	CMP	DL,79
	JNE	NOT_AT_END_OF_LINE
	JMP	PRE_PRINT_CHAR
NOT_AT_END_OF_LINE:	PUSH	DS
	MOV	AX,0B800H
	MOV	DS,AX	;SET DATA SEGMENT TO VIDEO SEGMENT
	MOV	AL,160	;NUMBER OF BYTES PER LINE OF SCREEN
	MUL	DH	;AX HAS ADDRESS OF CURSOR LINE
	MOV	BX,AX	;BX HAS ADDRESS OF CURSOR LINE
	MOV	CL,80	;80 CHARACTERS PER LINE
	INC	DL
	SUB	CL,DL	;CL HAS NUMBER OF CHARACTERS TO MOVE RIGHT
	STD	;SET DIRECTION FLAG TO DECREASE SOURCE INDEX AND DI
	ADD	BX,156	;BX POINTS TO SECOND TO LAST CHARACTER OF LINE
	MOV	SI,BX	;SI HAS ADDRESS OF FIRST CHARACTER TO MOVE
	MOV	AX,DS
	MOV	ES,AX
	ADD	BX,2
	MOV	DI,BX	;DI POINTS TO DESTINATION OF FIRST CHARACTER
REP	MOVSW	;PERFORM AN INSERT OF ONE CHARACTER ON CURRENT LINE
	POP	DS	;RESTORE DATA SEGMENT
	CLD	;RESET DIRECTION FLAG TO FORWARD
	JMP	PRE_PRINT_CHAR
ECHO_OFF:	AND	BYTE PTR FLAG,11111101B	;TURN OFF ECHO FLAG
	JMP	GET_CHR
ECHO_ON:	OR	BYTE PTR FLAG,00000010B	;TURN ON ECHO FLAG
	JMP	GET_CHR
FLAG	DB	00001000B	;EMULATION ON
ATTR	DB	00000010B
CLR	DB	00000010B
HIGHATT	DB	11111000B
HIGH1	DB	00000100B
BLINK	DB	01111111B
BLINK1	DB	10000000B
REV	DB	10001000B
REV1	DB	00100100B
NORM	DB	10001000B
NORM1	DB	00000010B
TOP	DB	0
BOT	DB	23
CSR_ROW	DB	0
COM_PORT	DW	3FCH
CSR_COL	DB	0
G0	DB	'A'	;SET CHARACTER SET G0 AS ASCII FOR DEFAULT
G1	DB	'A'	;SET CHARACTER SET G1 AS ASCII FOR DEFAULT
GL	DB	0	;SET CHARACTER SET GL AS G0 FOR DEFAULT
COMM_	DB	10011010B
COMMAND	DB	'COMMAND?  '
SET_PROMPT	DB	'SET COMMAND?  '
BAUD_PROMPT	DB	'BAUD RATE (1 = 300 bps, 2 = 1200 bps)?  '
COM_PROMPT	DB	'COM1 OR COM2 (1 OR 2)?  '
EM_OFF	DB	'EMULATION IS OFF. '
EM_ON	DB	'EMULATION IS ON. '
PROG_TITLE	DB	'VCOMM  '
	DB	73 DUP (219)
TAB	DB	8 DUP (0)
	DB	1
	DB	8 DUP (0,0,0,0,0,0,0,1)
	DB	6 DUP (0)
END_TAB	DB	0
GRAPHIC_SET	DB	32,4,176,9,144,13,10,248,'ñ¥',11,'Ù¿ÚÀÅßßÄ__'
	DB	'Ã´ÁÂ³óòãØœú',127
GET	PROC	NEAR
	PUSH	AX
	PUSH	CX
	MOV	CX,3
TRYMORE:	MOV	AH,2
	MOV	DX,0
	INT	14H
	CMP	AL,0
	JE	NO_CHR
KEYBOARD_CHAR:	MOV	DL,AL
	POP	CX
	POP	AX
	RET
NO_CHR:	MOV	AH,1
	INT	16H	;CHECK TO SEE IF A KEY NEEDS TO BE TRANSMITTED
	JZ	NO_CHR1
	PUSH	AX	;SAVE CHARACTER TO BE TRANSMITTED
	MOV	AH,0
	INT	16H
	CALL	TRNSMIT
	POP	AX	;RETREIVE CHARACTER THAT WAS TRANSMITTED
	TEST	BYTE PTR FLAG,00000010B	;SEE IF ECHO IS ON
	JZ	NO_CHR1
	JMP	KEYBOARD_CHAR
NO_CHR1:	LOOP	TRYMORE	;ALLOW FOR SLOW TRANS. OF ESC CODES
	POP	CX
	POP	AX
	POP	DX	;GET CONTENTS OF IP REGISTER OFF STACK
	JMP	GET_CHR
GET	ENDP
INC_CSR	PROC	NEAR
	CALL	GET_CSR
INC_	PROC	NEAR
	TEST	BYTE PTR FLAG,00010000B
	JNZ	OUT_MAR	;CURSOR HAS BEEN POSITIONED OUT OF THE MARGINS
	INC	DL
	CMP	DL,80
	JE	GTR_80
	CMP	DH,BOT
	JG	LINEFED
	CALL	POS
	RET
GTR_80:	TEST	BYTE PTR FLAG,00100000B
	JNZ	NEW_LIN	;END OF LINE WRAP IS ON
	MOV	DL,79
	CALL	POS
	RET
NEW_LIN:	MOV	DL,0
	INC	DH
	CMP	DH,BOT
	JG	GTR_24
	CALL	POS	;BRING CURSOR TO X=0 , Y=Y+1
	RET
GTR_24:	MOV	DL,0
LINEFED:	MOV	DH,BOT
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	AX
	MOV	AH,6
	MOV	AL,1
	MOV	CH,TOP
	MOV	CL,0
	MOV	DH,BOT
	MOV	DL,79
	MOV	BH,NORM1	;SET ATTRIBUTE TO NORMAL
	INT	10H	;SCROLL SCREEN
	POP	AX
	POP	BX
	POP	CX
	POP	DX
	CALL	POS
	RET
OUT_MAR:	INC	DL	;DH,DL NOW POINT TO WHERE CURSOR SHOULD BE
	CMP	DL,80
	JNE	OK_HORZ
	JMP	OUT_HOR
OK_HORZ:	CMP	DH,24
	JE	MAK_BOT
	CALL	POS
	JMP	CHK_MAR
MAK_BOT:	MOV	DH,23
	CALL	POS
	JMP	CHK_MAR
OUT_HOR:	TEST	BYTE PTR FLAG,00100000B
	JNZ	OUTHOR1
	MOV	DL,79
	CALL	POS
	JMP	CHK_MAR
OUTHOR1:	MOV	DL,0
	INC	DH
	CMP	DH,24
	JE	MAK_BOT
	CALL	POS
CHK_MAR:	CALL	GET_CSR
	CMP	DH,TOP
	JL	GETLOST
	CMP	DH,BOT
	JG	GETLOST
	AND	BYTE PTR FLAG,11101111B
GETLOST:	RET
INC_	ENDP
INC_CSR	ENDP
POS	PROC	NEAR
	PUSH	AX
	PUSH	BX
	MOV	AH,2
	MOV	BX,0
	INT	10H
	POP	BX
	POP	AX
	RET
POS	ENDP
GET_CSR	PROC	NEAR
	PUSH	AX
	PUSH	BX
	MOV	AH,3
	MOV	BX,0
	INT	10H	;GET CSR POS. - ROW IN DH - COL IN DL
	POP	BX
	POP	AX
	RET
GET_CSR	ENDP
TRNSMIT	PROC	NEAR
	PUSH	AX
	PUSH	DX
	MOV	AH,1
	MOV	DX,0
	INT	14H
	TEST	BYTE PTR FLAG,00000001B	;SEE IF CALL FROM KEY INPUT
	JZ	ECHO_NOT_ON
	POP	DX
	POP	AX
	POP	DX	;RETREIVE RETURN ADDRESS FROM STACK
	AND	BYTE PTR FLAG,11111110B	;TURN OFF KEY INPUT FLAG
	MOV	DL,AL
	JMP	INTERPRET_CHAR
ECHO_NOT_ON:	POP	DX
	POP	AX
	RET
TRNSMIT	ENDP
CLR_SCRN	PROC	NEAR	;NEEDS CORNERS IN CX AND DX
	PUSH	AX
	PUSH	BX
	MOV	AH,6
	MOV	AL,0
	MOV	BH,NORM1	;SET ATTRIBUTE TO NORMAL
	INT	10H	;PERFORMS A CLS
	POP	BX
	POP	AX
	RET
CLR_SCRN	ENDP
GET_KEY	PROC	NEAR
	MOV	AH,7
	INT	21H	;KEY IN AL
	CMP	AL,97
	JGE	LOWER_CASE
	RET
LOWER_CASE:	SUB	AL,32	;CONVERT KEY TO UPPER CASE
	RET
GET_KEY	ENDP
SAV_CSR	PROC	NEAR
	CALL	GET_CSR
	MOV	CSR_ROW,DH
	MOV	CSR_COL,DL
	RET
SAV_CSR	ENDP
RES_CSR	PROC	NEAR
	PUSH	DX
	MOV	DL,CSR_COL
	MOV	DH,CSR_ROW
	CALL	POS
	POP	DX
	RET
RES_CSR	ENDP
COMMAND_LINE	PROC	NEAR	;# CHARS IN CX - ADD OF PROMPT IN BX
	PUSH	AX
	PUSH	DX
	MOV	DH,24
	MOV	DL,0
	CALL	POS
DISP_CHAR:	PUSH	CX
	PUSH	BX
	MOV	AH,9
	MOV	AL,[BX]	;CHAR. TO PRINT
	MOV	BH,0	;PAGE NUMBER
	MOV	CX,1	;ONE CHAR. TO PRINT
	MOV	BL,NORM1	;ATTRIBUTE
	INT	10H
	CALL	GET_CSR
	INC	DL
	CMP	DL,80
	JNE	CSR_OK
	MOV	DL,79
CSR_OK:	CALL	POS
	POP	BX
	POP	CX
	ADD	BX,1
	LOOP	DISP_CHAR	;DISPLAY PROMPT
	CALL	GET_CSR
	DEC	DL
	CMP	DL,0FFH	;-1
	JNE	PLACE_CSR
	MOV	DL,0
PLACE_CSR:	CALL	POS	;POS. CURSOR ON LAST CHAR. OF PROMPT
	POP	DX
	POP	AX
	RET
COMMAND_LINE	ENDP
SET_COMM	PROC	NEAR
	PUSH	AX
	PUSH	DX
	MOV	AH,0
	MOV	AL,COMM_
	MOV	DX,0	;COMM PORT 1
	INT	14H
	POP	DX
	POP	AX
	RET
SET_COMM	ENDP
EXIT:	MOV	CX,0
	MOV	DH,24
	MOV	DL,79
	CALL	CLR_SCRN
	RET
NUM1:	DB	0
NUM2:	DB	0
MAIN	ENDP
PROGNAM	ENDS
	END	START
